// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;

// Disable unused variable warnings which
// can happen during the parser generation.
#pragma warning disable 168

namespace TinyPG
{
    #region Parser

    public partial class Parser 
    {
        private Scanner scanner;
        private ParseTree tree;
        
        public Parser(Scanner scanner)
        {
            this.scanner = scanner;
        }

         public ParseTree Parse(string input)
        {
            return Parse(input, "", new ParseTree());
        }

        public ParseTree Parse(string input, string fileName)
        {
            return Parse(input, fileName, new ParseTree());
        }

        public ParseTree Parse(string input, string fileName, ParseTree tree)
        {
            scanner.Init(input, fileName);

            this.tree = tree;
            ParseStart(tree);
            tree.Skipped = scanner.Skipped;

            return tree;
        }

        private void ParseStart(ParseNode parent) // NonTerminalSymbol: Start
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Start), "Start");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseGramatica(node); // NonTerminal Rule: Gramatica

             // Concat Rule
            tok = scanner.Scan(TokenType.EOF); // Terminal Rule: EOF
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.EOF) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.EOF.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Start

        private void ParseGramatica(ParseNode parent) // NonTerminalSymbol: Gramatica
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Gramatica), "Gramatica");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseSets(node); // NonTerminal Rule: Sets

             // Concat Rule
            ParseTokens(node); // NonTerminal Rule: Tokens

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Gramatica

        private void ParseSets(ParseNode parent) // NonTerminalSymbol: Sets
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Sets), "Sets");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.PR_SETS); // Option Rule
            if (tok.Type == TokenType.PR_SETS)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.PR_SETS); // Terminal Rule: PR_SETS
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.PR_SETS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PR_SETS.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseCuerpoSets(node); // NonTerminal Rule: CuerpoSets
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Sets

        private void ParseCuerpoSets(ParseNode parent) // NonTerminalSymbol: CuerpoSets
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CuerpoSets), "CuerpoSets");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                ParseListaSets(node); // NonTerminal Rule: ListaSets
                tok = scanner.LookAhead(TokenType.IDENTIFICADOR); // OneOrMore Rule
            } while (tok.Type == TokenType.IDENTIFICADOR); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CuerpoSets

        private void ParseListaSets(ParseNode parent) // NonTerminalSymbol: ListaSets
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListaSets), "ListaSets");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFICADOR); // Terminal Rule: IDENTIFICADOR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFICADOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFICADOR.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IGUAL); // Terminal Rule: IGUAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IGUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IGUAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseSetDef(node); // NonTerminal Rule: SetDef

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListaSets

        private void ParseSetDef(ParseNode parent) // NonTerminalSymbol: SetDef
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SetDef), "SetDef");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseDef(node); // NonTerminal Rule: Def

             // Concat Rule
            tok = scanner.LookAhead(TokenType.MAS); // ZeroOrMore Rule
            while (tok.Type == TokenType.MAS)
            {

                 // Concat Rule
                tok = scanner.Scan(TokenType.MAS); // Terminal Rule: MAS
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MAS) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MAS.ToString(), 0x1001, tok));
                    return;
                }

                 // Concat Rule
                ParseDef(node); // NonTerminal Rule: Def
            tok = scanner.LookAhead(TokenType.MAS); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: SetDef

        private void ParseDef(ParseNode parent) // NonTerminalSymbol: Def
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Def), "Def");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.COMILLA, TokenType.CHARF); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.COMILLA:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMILLA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.LETRA, TokenType.DIGITO); // Choice Rule
                    switch (tok.Type)
                    { // Choice Rule
                        case TokenType.LETRA:

                             // Concat Rule
                            tok = scanner.Scan(TokenType.LETRA); // Terminal Rule: LETRA
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.LETRA) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LETRA.ToString(), 0x1001, tok));
                                return;
                            }

                             // Concat Rule
                            tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.COMILLA) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                                return;
                            }

                             // Concat Rule
                            tok = scanner.LookAhead(TokenType.DOBLEPUNTO); // Option Rule
                            if (tok.Type == TokenType.DOBLEPUNTO)
                            {

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.DOBLEPUNTO); // Terminal Rule: DOBLEPUNTO
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.DOBLEPUNTO) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOBLEPUNTO.ToString(), 0x1001, tok));
                                    return;
                                }

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.COMILLA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                                    return;
                                }

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.LETRA); // Terminal Rule: LETRA
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.LETRA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LETRA.ToString(), 0x1001, tok));
                                    return;
                                }

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.COMILLA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                                    return;
                                }
                            }
                            break;
                        case TokenType.DIGITO:

                             // Concat Rule
                            tok = scanner.Scan(TokenType.DIGITO); // Terminal Rule: DIGITO
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.DIGITO) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIGITO.ToString(), 0x1001, tok));
                                return;
                            }

                             // Concat Rule
                            tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                            n = node.CreateNode(tok, tok.ToString() );
                            node.Token.UpdateRange(tok);
                            node.Nodes.Add(n);
                            if (tok.Type != TokenType.COMILLA) {
                                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                                return;
                            }

                             // Concat Rule
                            tok = scanner.LookAhead(TokenType.DOBLEPUNTO); // Option Rule
                            if (tok.Type == TokenType.DOBLEPUNTO)
                            {

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.DOBLEPUNTO); // Terminal Rule: DOBLEPUNTO
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.DOBLEPUNTO) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOBLEPUNTO.ToString(), 0x1001, tok));
                                    return;
                                }

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.COMILLA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                                    return;
                                }

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.DIGITO); // Terminal Rule: DIGITO
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.DIGITO) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DIGITO.ToString(), 0x1001, tok));
                                    return;
                                }

                                 // Concat Rule
                                tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                                n = node.CreateNode(tok, tok.ToString() );
                                node.Token.UpdateRange(tok);
                                node.Nodes.Add(n);
                                if (tok.Type != TokenType.COMILLA) {
                                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                                    return;
                                }
                            }
                            break;
                        default:
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected LETRA or DIGITO.", 0x0002, tok));
                            break;
                    } // Choice Rule
                    break;
                case TokenType.CHARF:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CHARF); // Terminal Rule: CHARF
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CHARF) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CHARF.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.PABIERTO); // Terminal Rule: PABIERTO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PABIERTO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PABIERTO.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.NUMERO); // Terminal Rule: NUMERO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.NUMERO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMERO.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.PCERRADO); // Terminal Rule: PCERRADO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PCERRADO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PCERRADO.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.DOBLEPUNTO); // Option Rule
                    if (tok.Type == TokenType.DOBLEPUNTO)
                    {

                         // Concat Rule
                        tok = scanner.Scan(TokenType.DOBLEPUNTO); // Terminal Rule: DOBLEPUNTO
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.DOBLEPUNTO) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.DOBLEPUNTO.ToString(), 0x1001, tok));
                            return;
                        }

                         // Concat Rule
                        tok = scanner.Scan(TokenType.CHARF); // Terminal Rule: CHARF
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.CHARF) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CHARF.ToString(), 0x1001, tok));
                            return;
                        }

                         // Concat Rule
                        tok = scanner.Scan(TokenType.PABIERTO); // Terminal Rule: PABIERTO
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PABIERTO) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PABIERTO.ToString(), 0x1001, tok));
                            return;
                        }

                         // Concat Rule
                        tok = scanner.Scan(TokenType.NUMERO); // Terminal Rule: NUMERO
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.NUMERO) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMERO.ToString(), 0x1001, tok));
                            return;
                        }

                         // Concat Rule
                        tok = scanner.Scan(TokenType.PCERRADO); // Terminal Rule: PCERRADO
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.PCERRADO) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PCERRADO.ToString(), 0x1001, tok));
                            return;
                        }
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected COMILLA or CHARF.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Def

        private void ParseTokens(ParseNode parent) // NonTerminalSymbol: Tokens
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Tokens), "Tokens");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseDeclaracionTokens(node); // NonTerminal Rule: DeclaracionTokens

             // Concat Rule
            ParseAcciones(node); // NonTerminal Rule: Acciones

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Tokens

        private void ParseDeclaracionTokens(ParseNode parent) // NonTerminalSymbol: DeclaracionTokens
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.DeclaracionTokens), "DeclaracionTokens");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PR_TOKENS); // Terminal Rule: PR_TOKENS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PR_TOKENS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PR_TOKENS.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCuerpoTokens(node); // NonTerminal Rule: CuerpoTokens

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: DeclaracionTokens

        private void ParseCuerpoTokens(ParseNode parent) // NonTerminalSymbol: CuerpoTokens
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CuerpoTokens), "CuerpoTokens");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                ParseListaTokens(node); // NonTerminal Rule: ListaTokens
                tok = scanner.LookAhead(TokenType.PR_TOKEN); // OneOrMore Rule
            } while (tok.Type == TokenType.PR_TOKEN); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CuerpoTokens

        private void ParseListaTokens(ParseNode parent) // NonTerminalSymbol: ListaTokens
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListaTokens), "ListaTokens");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PR_TOKEN); // Terminal Rule: PR_TOKEN
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PR_TOKEN) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PR_TOKEN.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NUMERO); // Terminal Rule: NUMERO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NUMERO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMERO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IGUAL); // Terminal Rule: IGUAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IGUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IGUAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseListaDefToken(node); // NonTerminal Rule: ListaDefToken

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListaTokens

        private void ParseListaDefToken(ParseNode parent) // NonTerminalSymbol: ListaDefToken
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListaDefToken), "ListaDefToken");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                ParseDefToken(node); // NonTerminal Rule: DefToken
                tok = scanner.LookAhead(TokenType.COMILLA, TokenType.LLABIERTA, TokenType.IDENTIFICADOR, TokenType.PABIERTO); // OneOrMore Rule
            } while (tok.Type == TokenType.COMILLA
                || tok.Type == TokenType.LLABIERTA
                || tok.Type == TokenType.IDENTIFICADOR
                || tok.Type == TokenType.PABIERTO); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListaDefToken

        private void ParseDefToken(ParseNode parent) // NonTerminalSymbol: DefToken
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.DefToken), "DefToken");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.COMILLA, TokenType.LLABIERTA, TokenType.IDENTIFICADOR, TokenType.PABIERTO); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.COMILLA:
                case TokenType.LLABIERTA:
                case TokenType.IDENTIFICADOR:
                    ParseSimpleToken(node); // NonTerminal Rule: SimpleToken
                    break;
                case TokenType.PABIERTO:
                    ParseAgrupaToken(node); // NonTerminal Rule: AgrupaToken
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected COMILLA, LLABIERTA, IDENTIFICADOR, or PABIERTO.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: DefToken

        private void ParseSimpleToken(ParseNode parent) // NonTerminalSymbol: SimpleToken
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.SimpleToken), "SimpleToken");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.COMILLA, TokenType.LLABIERTA, TokenType.IDENTIFICADOR); // Choice Rule
            switch (tok.Type)
            { // Choice Rule
                case TokenType.COMILLA:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMILLA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.CARACTER); // Terminal Rule: CARACTER
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.CARACTER) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.CARACTER.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.COMILLA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.MODIFICADOR); // Option Rule
                    if (tok.Type == TokenType.MODIFICADOR)
                    {
                        tok = scanner.Scan(TokenType.MODIFICADOR); // Terminal Rule: MODIFICADOR
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MODIFICADOR) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODIFICADOR.ToString(), 0x1001, tok));
                            return;
                        }
                    }
                    break;
                case TokenType.LLABIERTA:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.LLABIERTA); // Terminal Rule: LLABIERTA
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LLABIERTA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LLABIERTA.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.IDENTIFICADOR); // Terminal Rule: IDENTIFICADOR
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFICADOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFICADOR.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.PABIERTO); // Terminal Rule: PABIERTO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PABIERTO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PABIERTO.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.PCERRADO); // Terminal Rule: PCERRADO
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.PCERRADO) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PCERRADO.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.Scan(TokenType.LLCERRADA); // Terminal Rule: LLCERRADA
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.LLCERRADA) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LLCERRADA.ToString(), 0x1001, tok));
                        return;
                    }
                    break;
                case TokenType.IDENTIFICADOR:

                     // Concat Rule
                    tok = scanner.Scan(TokenType.IDENTIFICADOR); // Terminal Rule: IDENTIFICADOR
                    n = node.CreateNode(tok, tok.ToString() );
                    node.Token.UpdateRange(tok);
                    node.Nodes.Add(n);
                    if (tok.Type != TokenType.IDENTIFICADOR) {
                        tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFICADOR.ToString(), 0x1001, tok));
                        return;
                    }

                     // Concat Rule
                    tok = scanner.LookAhead(TokenType.MODIFICADOR); // Option Rule
                    if (tok.Type == TokenType.MODIFICADOR)
                    {
                        tok = scanner.Scan(TokenType.MODIFICADOR); // Terminal Rule: MODIFICADOR
                        n = node.CreateNode(tok, tok.ToString() );
                        node.Token.UpdateRange(tok);
                        node.Nodes.Add(n);
                        if (tok.Type != TokenType.MODIFICADOR) {
                            tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODIFICADOR.ToString(), 0x1001, tok));
                            return;
                        }
                    }
                    break;
                default:
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected COMILLA, LLABIERTA, or IDENTIFICADOR.", 0x0002, tok));
                    break;
            } // Choice Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: SimpleToken

        private void ParseAgrupaToken(ParseNode parent) // NonTerminalSymbol: AgrupaToken
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.AgrupaToken), "AgrupaToken");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PABIERTO); // Terminal Rule: PABIERTO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PABIERTO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PABIERTO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseListaDefToken(node); // NonTerminal Rule: ListaDefToken

             // Concat Rule
            tok = scanner.Scan(TokenType.PCERRADO); // Terminal Rule: PCERRADO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PCERRADO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PCERRADO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.LookAhead(TokenType.MODIFICADOR); // Option Rule
            if (tok.Type == TokenType.MODIFICADOR)
            {
                tok = scanner.Scan(TokenType.MODIFICADOR); // Terminal Rule: MODIFICADOR
                n = node.CreateNode(tok, tok.ToString() );
                node.Token.UpdateRange(tok);
                node.Nodes.Add(n);
                if (tok.Type != TokenType.MODIFICADOR) {
                    tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.MODIFICADOR.ToString(), 0x1001, tok));
                    return;
                }
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: AgrupaToken

        private void ParseAcciones(ParseNode parent) // NonTerminalSymbol: Acciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Acciones), "Acciones");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseDeclaracionAcciones(node); // NonTerminal Rule: DeclaracionAcciones

             // Concat Rule
            ParseErrores(node); // NonTerminal Rule: Errores

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Acciones

        private void ParseDeclaracionAcciones(ParseNode parent) // NonTerminalSymbol: DeclaracionAcciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.DeclaracionAcciones), "DeclaracionAcciones");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PR_ACCIONES); // Terminal Rule: PR_ACCIONES
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PR_ACCIONES) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PR_ACCIONES.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCuerpoAcciones(node); // NonTerminal Rule: CuerpoAcciones

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: DeclaracionAcciones

        private void ParseCuerpoAcciones(ParseNode parent) // NonTerminalSymbol: CuerpoAcciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CuerpoAcciones), "CuerpoAcciones");
            parent.Nodes.Add(node);


             // Concat Rule
            ParseFuncionReservadas(node); // NonTerminal Rule: FuncionReservadas

             // Concat Rule
            ParseListaFunciones(node); // NonTerminal Rule: ListaFunciones

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CuerpoAcciones

        private void ParseFuncionReservadas(ParseNode parent) // NonTerminalSymbol: FuncionReservadas
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.FuncionReservadas), "FuncionReservadas");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.PR_RESERVADAS); // Terminal Rule: PR_RESERVADAS
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PR_RESERVADAS) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PR_RESERVADAS.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.PABIERTO); // Terminal Rule: PABIERTO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PABIERTO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PABIERTO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.PCERRADO); // Terminal Rule: PCERRADO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PCERRADO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PCERRADO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCuerpoFunciones(node); // NonTerminal Rule: CuerpoFunciones

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: FuncionReservadas

        private void ParseCuerpoFunciones(ParseNode parent) // NonTerminalSymbol: CuerpoFunciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.CuerpoFunciones), "CuerpoFunciones");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.LLABIERTA); // Terminal Rule: LLABIERTA
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LLABIERTA) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LLABIERTA.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            do { // OneOrMore Rule
                ParseListaAcciones(node); // NonTerminal Rule: ListaAcciones
                tok = scanner.LookAhead(TokenType.NUMERO); // OneOrMore Rule
            } while (tok.Type == TokenType.NUMERO); // OneOrMore Rule

             // Concat Rule
            tok = scanner.Scan(TokenType.LLCERRADA); // Terminal Rule: LLCERRADA
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.LLCERRADA) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.LLCERRADA.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: CuerpoFunciones

        private void ParseListaAcciones(ParseNode parent) // NonTerminalSymbol: ListaAcciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListaAcciones), "ListaAcciones");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.NUMERO); // Terminal Rule: NUMERO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NUMERO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMERO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IGUAL); // Terminal Rule: IGUAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IGUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IGUAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMILLA) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFICADOR); // Terminal Rule: IDENTIFICADOR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFICADOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFICADOR.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.COMILLA); // Terminal Rule: COMILLA
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.COMILLA) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.COMILLA.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListaAcciones

        private void ParseListaFunciones(ParseNode parent) // NonTerminalSymbol: ListaFunciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListaFunciones), "ListaFunciones");
            parent.Nodes.Add(node);

            tok = scanner.LookAhead(TokenType.IDENTIFICADOR); // ZeroOrMore Rule
            while (tok.Type == TokenType.IDENTIFICADOR)
            {
                ParseOtrasFunciones(node); // NonTerminal Rule: OtrasFunciones
            tok = scanner.LookAhead(TokenType.IDENTIFICADOR); // ZeroOrMore Rule
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListaFunciones

        private void ParseOtrasFunciones(ParseNode parent) // NonTerminalSymbol: OtrasFunciones
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.OtrasFunciones), "OtrasFunciones");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDENTIFICADOR); // Terminal Rule: IDENTIFICADOR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDENTIFICADOR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDENTIFICADOR.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.PABIERTO); // Terminal Rule: PABIERTO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PABIERTO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PABIERTO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.PCERRADO); // Terminal Rule: PCERRADO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.PCERRADO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.PCERRADO.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            ParseCuerpoFunciones(node); // NonTerminal Rule: CuerpoFunciones

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: OtrasFunciones

        private void ParseErrores(ParseNode parent) // NonTerminalSymbol: Errores
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.Errores), "Errores");
            parent.Nodes.Add(node);

            do { // OneOrMore Rule
                ParseListaErrores(node); // NonTerminal Rule: ListaErrores
                tok = scanner.LookAhead(TokenType.IDERROR); // OneOrMore Rule
            } while (tok.Type == TokenType.IDERROR); // OneOrMore Rule

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: Errores

        private void ParseListaErrores(ParseNode parent) // NonTerminalSymbol: ListaErrores
        {
            Token tok;
            ParseNode n;
            ParseNode node = parent.CreateNode(scanner.GetToken(TokenType.ListaErrores), "ListaErrores");
            parent.Nodes.Add(node);


             // Concat Rule
            tok = scanner.Scan(TokenType.IDERROR); // Terminal Rule: IDERROR
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IDERROR) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IDERROR.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.IGUAL); // Terminal Rule: IGUAL
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.IGUAL) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.IGUAL.ToString(), 0x1001, tok));
                return;
            }

             // Concat Rule
            tok = scanner.Scan(TokenType.NUMERO); // Terminal Rule: NUMERO
            n = node.CreateNode(tok, tok.ToString() );
            node.Token.UpdateRange(tok);
            node.Nodes.Add(n);
            if (tok.Type != TokenType.NUMERO) {
                tree.Errors.Add(new ParseError("Unexpected token '" + tok.Text.Replace("\n", "") + "' found. Expected " + TokenType.NUMERO.ToString(), 0x1001, tok));
                return;
            }

            parent.Token.UpdateRange(node.Token);
        } // NonTerminalSymbol: ListaErrores


    }

    #endregion Parser
}
