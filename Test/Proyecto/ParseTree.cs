// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Xml.Serialization;

namespace TinyPG
{

    public class NodoToken
    {
        public Token token { get; set; }
        public NodoToken Izquierdo { get; set; }
        public NodoToken Derecho { get; set; }

        public int MaxNumero (NodoToken raiz)
        {
            int contador = 0;
            // recorre hacia la derecha
            NodoToken derecho = raiz.Derecho;
            while (derecho != null)
            {
                contador = derecho.token.Number;
            }
            return contador;
        }

    }

    public class ExprTree
    {
        public NodoToken Raiz { get; set; }
        public List<NodoToken> ListaExpr { get; set; }

        public int NumeroHoja { get; set; }

        public StringBuilder TokensExpr { get; set; }

        public ExprTree ()
        {
            Raiz = null;
            NumeroHoja = 0;
            TokensExpr = new StringBuilder();
            ListaExpr = new List<NodoToken>();
            ListaExpr.Add(Raiz);
        }

        private void AgregarToken(NodoToken nuevo)
        {
            NodoToken raiz = ListaExpr.Last();
            if (nuevo.token.Type == TokenType.IDENTIFICADOR || nuevo.token.Type == TokenType.CARACTER)
            {
                NumeroHoja += 1;
                nuevo.token.Number = NumeroHoja;
                nuevo.token.First.Add(NumeroHoja);
                nuevo.token.Last.Add(NumeroHoja);
                nuevo.token.Nullable = false;
            }
            if (raiz == null)
            {
                raiz = nuevo;
                raiz.Izquierdo = null;
                raiz.Derecho = null;
            }
            else
            {
                if (nuevo.token.Type == TokenType.MODIFICADOR)
                {
                    if (nuevo.token.Text.Equals("*") || nuevo.token.Text.Equals("?"))
                    {
                        nuevo.token.Nullable = true;
                    } else
                    {
                        nuevo.token.Nullable = false;
                    }
                    if (raiz.Derecho == null)
                    {
                        nuevo.token.First = raiz.token.First;
                        nuevo.token.Last = raiz.token.Last;
                        nuevo.Izquierdo = raiz;
                        raiz = nuevo;
                    } else
                    {
                        nuevo.token.First = raiz.Derecho.token.First;
                        nuevo.token.Last = raiz.Derecho.token.Last;
                        nuevo.Izquierdo = raiz.Derecho;
                        raiz.Derecho = nuevo;
                    }
                    
                }
                else if (nuevo.token.Type == TokenType.OPCIONAL && nuevo.Izquierdo == null)
                {
                    nuevo.Izquierdo = raiz;
                    raiz = nuevo;
                }
                else
                {
                    if (raiz.token.Type == TokenType.OPCIONAL && raiz.Derecho == null)
                    {
                        raiz.Derecho = nuevo;
                        raiz.token.Nullable = raiz.Izquierdo.token.Nullable || raiz.Derecho.token.Nullable;
                        raiz.token.First = raiz.Izquierdo.token.First.Concat(raiz.Derecho.token.First).ToList();
                        raiz.token.Last = raiz.Izquierdo.token.Last.Concat(raiz.Derecho.token.Last).ToList();
                    } else if (raiz.token.Type == TokenType.MODIFICADOR)
                    {
                        nuevo.Derecho = raiz;
                        raiz = nuevo;
                    } else
                    {
                        NodoToken nuevoConcatenar = new NodoToken();
                        nuevoConcatenar.token = new Token();
                        nuevoConcatenar.token.Type = TokenType.CONCATENACION;
                        nuevoConcatenar.token.Text = ".";
                        nuevoConcatenar.Izquierdo = raiz;
                        nuevoConcatenar.Derecho = nuevo;
                        nuevoConcatenar.token.Nullable = nuevoConcatenar.Izquierdo.token.Nullable && nuevoConcatenar.Derecho.token.Nullable;
                        if (nuevoConcatenar.Izquierdo.token.Nullable)
                        {
                            nuevoConcatenar.token.First = nuevoConcatenar.Izquierdo.token.First.Concat(nuevoConcatenar.Derecho.token.First).ToList();
                        } else
                        {
                            nuevoConcatenar.token.First = nuevoConcatenar.Izquierdo.token.First;
                        }
                        if (nuevoConcatenar.Derecho.token.Nullable)
                        {
                            nuevoConcatenar.token.Last = nuevoConcatenar.Izquierdo.token.Last.Concat(nuevoConcatenar.Derecho.token.Last).ToList();
                        }
                        else
                        {
                            nuevoConcatenar.token.Last = nuevoConcatenar.Derecho.token.Last;
                        }
                        raiz = nuevoConcatenar;
                    }
                }
            }
            // actualiza raiz en la lista
            ListaExpr.RemoveAt(ListaExpr.Count() - 1);
            ListaExpr.Add(raiz);
        }

        public void GeneraArbolExpr ( ParseTree tree )
        {
           foreach (ParseNode node in tree.Nodes)
            {
                FindTokens(node);
            }
           while (ListaExpr.Count() > 1)
            {
                NodoToken raizTemporal = ListaExpr.Last();
                ListaExpr.RemoveAt(ListaExpr.Count() - 1);
                AgregarToken(raizTemporal);
            }
            Raiz = ListaExpr.Last();
        }

        private void FindTokens(ParseNode node)
        {
            foreach (ParseNode n in node.Nodes)
            {
                if (n.Token.Type == TokenType.PR_TOKEN)
                {
                    if (ListaExpr.Last() != null)
                    {
                        if (ListaExpr.Count() > 1)
                        {
                            NodoToken raizTemporal = ListaExpr.Last();
                            ListaExpr.RemoveAt(ListaExpr.Count() - 1);
                            AgregarToken(raizTemporal);
                        }
                        TokensExpr.Append("| ");
                        NodoToken nuevoOpcional = new NodoToken();
                        nuevoOpcional.token = new Token();
                        nuevoOpcional.token.Type = TokenType.OPCIONAL;
                        nuevoOpcional.token.Text = "|";
                        AgregarToken(nuevoOpcional);
                        // Agrupa la nueva expresion
                        NodoToken nuevaRaiz = null;
                        ListaExpr.Add(nuevaRaiz);
                    }
                }
                if (node.Token.Type == TokenType.SimpleToken)
                {
                    if (n.Token.Type == TokenType.IDENTIFICADOR || n.Token.Type == TokenType.MODIFICADOR || n.Token.Type == TokenType.CARACTER)
                    { 
                        TokensExpr.Append(n.Token.Text); 
                        TokensExpr.Append(" ");
                        NodoToken nuevoToken = new NodoToken();
                        nuevoToken.token = n.Token;
                        AgregarToken(nuevoToken);
                    }
                }
                if (node.Token.Type == TokenType.OpcionalToken)
                {
                    if (n.Token.Type == TokenType.OPCIONAL)
                    {
                        TokensExpr.Append(n.Token.Text);
                        TokensExpr.Append(" ");
                        NodoToken nuevoToken = new NodoToken();
                        nuevoToken.token = n.Token;
                        AgregarToken(nuevoToken);
                    }

                }
                if (node.Token.Type == TokenType.AgrupaToken)
                {
                    if (n.Token.Type == TokenType.PABIERTO)
                    {
                        TokensExpr.Append(n.Token.Text);
                        TokensExpr.Append(" ");
                        NodoToken nuevaRaiz = null;
                        ListaExpr.Add(nuevaRaiz);
                    }
                    if (n.Token.Type == TokenType.PCERRADO)
                    {
                        TokensExpr.Append(n.Token.Text);
                        TokensExpr.Append(" ");
                        NodoToken raizTemporal = ListaExpr.Last();
                        ListaExpr.RemoveAt(ListaExpr.Count() - 1);
                        AgregarToken(raizTemporal);
                    }
                    if (n.Token.Type == TokenType.MODIFICADOR)
                    {
                        TokensExpr.Append(n.Token.Text);
                        TokensExpr.Append(" ");
                        NodoToken nuevoToken = new NodoToken();
                        nuevoToken.token = n.Token;
                        AgregarToken(nuevoToken);
                    }
                }
                FindTokens(n);
            }
        }

        public string InFijo()
        {
            StringBuilder texto = new StringBuilder();
            RecorreInfijo(Raiz, texto);
            return texto.ToString();
        }

        private void RecorreInfijo(NodoToken nodo, StringBuilder texto)
        {
            if (nodo == null) return;
            RecorreInfijo(nodo.Izquierdo, texto);
            texto.Append(nodo.token.Text);
            texto.Append(" ");
            RecorreInfijo(nodo.Derecho, texto);
        }

        public List<string[]> TablaFirsLastNullable()
        {
            List<string[]> rows = new List<string[]>();
            RecorreFirstLastNullable(Raiz, rows);
            return rows;
        }

        private void RecorreFirstLastNullable(NodoToken nodo, List<string[]> rows)
        {
            if (nodo == null) return;
            RecorreFirstLastNullable(nodo.Izquierdo, rows);
            string[] row = new string[] { nodo.token.Text, String.Join(", ", nodo.token.First.ToArray()), String.Join(", ", nodo.token.Last.ToArray()), nodo.token.Nullable.ToString() };
            rows.Add(row);
            RecorreFirstLastNullable(nodo.Derecho, rows);
        }

        public string Dotify()
        {
            StringBuilder texto = new StringBuilder();
            texto.AppendLine(GenerateDotHeader());
            if (Raiz.Izquierdo == null && Raiz.Derecho == null)
                texto.AppendLine(Raiz.token.Text);
            else
                DotifyInfijo(Raiz, texto);
            texto.AppendLine(GenerateDotFooter());
            return texto.ToString();
        }

        private void DotifyInfijo(NodoToken nodo, StringBuilder texto)
        {
            if (nodo == null) return;
            if (nodo.Izquierdo != null)
            {
                texto.Append('"' + String.Join(",",nodo.token.First.ToArray()) + (nodo.token.Text.Equals('"') ? ("\\" + '"') : nodo.token.Text) + String.Join(",", nodo.token.Last.ToArray()) + '"');
                texto.Append(" -> ");
                texto.AppendLine('"' + String.Join(",", nodo.Izquierdo.token.First.ToArray()) + (nodo.Izquierdo.token.Text.Equals('"') ? ("\\" + '"') : nodo.Izquierdo.token.Text) + String.Join(",", nodo.Izquierdo.token.Last.ToArray()) + '"' + ';');
                DotifyInfijo(nodo.Izquierdo, texto);
            }
            if (nodo.Derecho != null)
            {
                texto.Append('"' + String.Join(",", nodo.token.First.ToArray()) + (nodo.token.Text.Equals('"') ? ("\\" + '"') : nodo.token.Text) + String.Join(",", nodo.token.Last.ToArray()) + '"');
                texto.Append(" -> ");
                texto.AppendLine('"' + String.Join(",", nodo.Derecho.token.First.ToArray()) + (nodo.Derecho.token.Text.Equals('"') ? ("\\" + '"') : nodo.Derecho.token.Text) + String.Join(",", nodo.Derecho.token.Last.ToArray()) + '"' + ';');
                DotifyInfijo(nodo.Derecho, texto);
            }
        }

        private string GenerateDotHeader()
        {
            return @"
      digraph G {
        rankdir=BT;

        node [
          fontname = ""Bitstream Vera Sans""
          fontsize = 10
          shape = ""record""
        ]

        edge [
          fontname = ""Bitstream Vera Sans""
          fontsize = 8
          arrowhead = ""empty""
        ]
";
        }

        private string GenerateDotFooter()
        {
            return "\n}\n";
        }

    }

    #region ParseTree
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string file;
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public string File { get { return file; } }
        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            this.file = file;
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }


        public string Dotify()
        {
            StringBuilder dot = new StringBuilder();
            ParseTree node = this;

            dot.Append(this.GenerateDotHeader());

            //this.GenerateEntity(dot, node);
            List<string> tempDot = new List<string>();
            this.GenerateGeneralizations(tempDot, node);
            IEnumerable<string> distinctLines = tempDot.Distinct();
            foreach (string line in distinctLines)
            {
                dot.AppendLine(line);
            }

            dot.Append(this.GenerateDotFooter());

            return dot.ToString();
        }

        private string GenerateDotHeader()
        {
            return @"
      digraph G {
        rankdir=BT;

        node [
          fontname = ""Bitstream Vera Sans""
          fontsize = 10
          shape = ""record""
        ]

        edge [
          fontname = ""Bitstream Vera Sans""
          fontsize = 8
          arrowhead = ""empty""
        ]
";
        }

        private string GenerateDotFooter()
        {
            return "\n}\n";
        }

        private void GenerateEntity(StringBuilder dot, ParseNode node)
        {
            // Entity [
            //   label = "{Entity|+ property : type\l ... |+ method() : void\l}"
            // ]
            dot.AppendLine("\n");
            string label = "";
            label = "\n" + node.Token.Type.ToString() +
              " [ label = \"{" +  // node.Token.Type.ToString() + "|" +
              node.Token.Type.ToString() + ':' + node.Token.Value;
            label += "}\" ]";
            dot.Append(label);

            foreach (ParseNode n in node.Nodes)
                GenerateEntity(dot, n);
        }

        private void GenerateGeneralizations(List<string> lista, ParseNode node)
        {
            // Sub1 -> Entity
            // Sub2 -> Entity
            // { rank=same Sub1, Sub2 }
            string label = "";
            foreach (ParseNode sub in node.Nodes)
            {
                GenerateGeneralizations(lista, sub);
                label = sub.Token.Type.ToString() + " -> " + node.Token.Type.ToString();
                lista.Add(label);
            }
            
            //if (node.Nodes.Count > 1)
            //{
            //    label += "\n{ rank=same " +
            //      string.Join(",", node.Nodes.Select(s => s.Text)) + "}";
            //    dot.Append(label);
            //}
        }

        // TODO reuse from Emitter ;-)
        private string PascalCase(string text)
        {
            return string.Join("",
              text.Split('-').Select(x =>
                x.First().ToString().ToUpper() + x.ToLower().Substring(1)
              )
            );
        }

        private string GenerateType(string type)
        {
            if (type == null) { return "Object"; }
            if (type.Equals("<string>")) { return "string"; }
            if (type.Equals("<bool>")) { return "bool"; }
            return this.PascalCase(type);
        }

        private string PluralSuffix(string text)
        {
            if (text.EndsWith("x")) { return "es"; }
            if (text.EndsWith("s")) { return ""; }
            return "s";
        }

    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.Gramatica:
                    Value = EvalGramatica(tree, paramlist);
                    break;
                case TokenType.Sets:
                    Value = EvalSets(tree, paramlist);
                    break;
                case TokenType.CuerpoSets:
                    Value = EvalCuerpoSets(tree, paramlist);
                    break;
                case TokenType.ListaSets:
                    Value = EvalListaSets(tree, paramlist);
                    break;
                case TokenType.SetDef:
                    Value = EvalSetDef(tree, paramlist);
                    break;
                case TokenType.Def:
                    Value = EvalDef(tree, paramlist);
                    break;
                case TokenType.Tokens:
                    Value = EvalTokens(tree, paramlist);
                    break;
                case TokenType.DeclaracionTokens:
                    Value = EvalDeclaracionTokens(tree, paramlist);
                    break;
                case TokenType.CuerpoTokens:
                    Value = EvalCuerpoTokens(tree, paramlist);
                    break;
                case TokenType.ListaTokens:
                    Value = EvalListaTokens(tree, paramlist);
                    break;
                case TokenType.ListaDefToken:
                    Value = EvalListaDefToken(tree, paramlist);
                    break;
                case TokenType.CondicionToken:
                    Value = EvalCondicionToken(tree, paramlist);
                    break;
                case TokenType.OpcionalToken:
                    Value = EvalOpcionalToken(tree, paramlist);
                    break;
                case TokenType.DefToken:
                    Value = EvalDefToken(tree, paramlist);
                    break;
                case TokenType.SimpleToken:
                    Value = EvalSimpleToken(tree, paramlist);
                    break;
                case TokenType.AgrupaToken:
                    Value = EvalAgrupaToken(tree, paramlist);
                    break;
                case TokenType.Acciones:
                    Value = EvalAcciones(tree, paramlist);
                    break;
                case TokenType.DeclaracionAcciones:
                    Value = EvalDeclaracionAcciones(tree, paramlist);
                    break;
                case TokenType.CuerpoAcciones:
                    Value = EvalCuerpoAcciones(tree, paramlist);
                    break;
                case TokenType.FuncionReservadas:
                    Value = EvalFuncionReservadas(tree, paramlist);
                    break;
                case TokenType.CuerpoFunciones:
                    Value = EvalCuerpoFunciones(tree, paramlist);
                    break;
                case TokenType.ListaAcciones:
                    Value = EvalListaAcciones(tree, paramlist);
                    break;
                case TokenType.ListaFunciones:
                    Value = EvalListaFunciones(tree, paramlist);
                    break;
                case TokenType.OtrasFunciones:
                    Value = EvalOtrasFunciones(tree, paramlist);
                    break;
                case TokenType.Errores:
                    Value = EvalErrores(tree, paramlist);
                    break;
                case TokenType.ListaErrores:
                    Value = EvalListaErrores(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            return "Could not interpret input; no semantics implemented.";
        }

        protected virtual object EvalGramatica(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSets(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoSets(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaSets(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSetDef(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDef(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDeclaracionTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaDefToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCondicionToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalOpcionalToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDefToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSimpleToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalAgrupaToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDeclaracionAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalFuncionReservadas(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoFunciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaFunciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalOtrasFunciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalErrores(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaErrores(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }


    }
    
    #endregion ParseTree
}
