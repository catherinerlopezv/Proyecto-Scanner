// Generated by TinyPG v1.3 available at www.codeproject.com

using System;
using System.Collections.Generic;
using System.Text;
using System.Linq;
using System.Xml.Serialization;

namespace TinyPG
{
    #region ParseTree
    [Serializable]
    public class ParseErrors : List<ParseError>
    {
    }

    [Serializable]
    public class ParseError
    {
        private string file;
        private string message;
        private int code;
        private int line;
        private int col;
        private int pos;
        private int length;

        public string File { get { return file; } }
        public int Code { get { return code; } }
        public int Line { get { return line; } }
        public int Column { get { return col; } }
        public int Position { get { return pos; } }
        public int Length { get { return length; } }
        public string Message { get { return message; } }

        // just for the sake of serialization
        public ParseError()
        {
        }

        public ParseError(string message, int code, ParseNode node) : this(message, code, node.Token)
        {
        }

        public ParseError(string message, int code, Token token) : this(message, code, token.File, token.Line, token.Column, token.StartPos, token.Length)
        {
        }

        public ParseError(string message, int code) : this(message, code, string.Empty, 0, 0, 0, 0)
        {
        }

        public ParseError(string message, int code, string file, int line, int col, int pos, int length)
        {
            this.file = file;
            this.message = message;
            this.code = code;
            this.line = line;
            this.col = col;
            this.pos = pos;
            this.length = length;
        }
    }

    // rootlevel of the node tree
    [Serializable]
    public partial class ParseTree : ParseNode
    {
        public ParseErrors Errors;

        public List<Token> Skipped;

        public ParseTree() : base(new Token(), "ParseTree")
        {
            Token.Type = TokenType.Start;
            Token.Text = "Root";
            Errors = new ParseErrors();
        }

        public string PrintTree()
        {
            StringBuilder sb = new StringBuilder();
            int indent = 0;
            PrintNode(sb, this, indent);
            return sb.ToString();
        }

        private void PrintNode(StringBuilder sb, ParseNode node, int indent)
        {
            
            string space = "".PadLeft(indent, ' ');

            sb.Append(space);
            sb.AppendLine(node.Text);

            foreach (ParseNode n in node.Nodes)
                PrintNode(sb, n, indent + 2);
        }
        
        /// <summary>
        /// this is the entry point for executing and evaluating the parse tree.
        /// </summary>
        /// <param name="paramlist">additional optional input parameters</param>
        /// <returns>the output of the evaluation function</returns>
        public object Eval(params object[] paramlist)
        {
            return Nodes[0].Eval(this, paramlist);
        }


        public string Dotify()
        {
            StringBuilder dot = new StringBuilder();
            ParseTree node = this;

            dot.Append(this.GenerateDotHeader());

            //this.GenerateEntity(dot, node);
            List<string> tempDot = new List<string>();
            this.GenerateGeneralizations(tempDot, node);
            IEnumerable<string> distinctLines = tempDot.Distinct();
            foreach (string line in distinctLines)
            {
                dot.AppendLine(line);
            }

            dot.Append(this.GenerateDotFooter());

            return dot.ToString();
        }

        private string GenerateDotHeader()
        {
            return @"
      digraph G {
        rankdir=BT;

        node [
          fontname = ""Bitstream Vera Sans""
          fontsize = 10
          shape = ""record""
        ]

        edge [
          fontname = ""Bitstream Vera Sans""
          fontsize = 8
          arrowhead = ""empty""
        ]
";
        }

        private string GenerateDotFooter()
        {
            return "\n}\n";
        }

        private void GenerateEntity(StringBuilder dot, ParseNode node)
        {
            // Entity [
            //   label = "{Entity|+ property : type\l ... |+ method() : void\l}"
            // ]
            dot.AppendLine("\n");
            string label = "";
            label = "\n" + node.Token.Type.ToString() +
              " [ label = \"{" +  // node.Token.Type.ToString() + "|" +
              node.Token.Type.ToString() + ':' + node.Token.Value;
            label += "}\" ]";
            dot.Append(label);

            foreach (ParseNode n in node.Nodes)
                GenerateEntity(dot, n);
        }

        private void GenerateGeneralizations(List<string> lista, ParseNode node)
        {
            // Sub1 -> Entity
            // Sub2 -> Entity
            // { rank=same Sub1, Sub2 }
            string label = "";
            foreach (ParseNode sub in node.Nodes)
            {
                GenerateGeneralizations(lista, sub);
                label = sub.Token.Type.ToString() + " -> " + node.Token.Type.ToString();
                lista.Add(label);
            }
            
            //if (node.Nodes.Count > 1)
            //{
            //    label += "\n{ rank=same " +
            //      string.Join(",", node.Nodes.Select(s => s.Text)) + "}";
            //    dot.Append(label);
            //}
        }

        // TODO reuse from Emitter ;-)
        private string PascalCase(string text)
        {
            return string.Join("",
              text.Split('-').Select(x =>
                x.First().ToString().ToUpper() + x.ToLower().Substring(1)
              )
            );
        }

        private string GenerateType(string type)
        {
            if (type == null) { return "Object"; }
            if (type.Equals("<string>")) { return "string"; }
            if (type.Equals("<bool>")) { return "bool"; }
            return this.PascalCase(type);
        }

        private string PluralSuffix(string text)
        {
            if (text.EndsWith("x")) { return "es"; }
            if (text.EndsWith("s")) { return ""; }
            return "s";
        }

    }

    [Serializable]
    [XmlInclude(typeof(ParseTree))]
    public partial class ParseNode
    {
        protected string text;
        protected List<ParseNode> nodes;
        
        public List<ParseNode> Nodes { get {return nodes;} }
        
        [XmlIgnore] // avoid circular references when serializing
        public ParseNode Parent;
        public Token Token; // the token/rule

        [XmlIgnore] // skip redundant text (is part of Token)
        public string Text { // text to display in parse tree 
            get { return text;} 
            set { text = value; }
        } 

        public virtual ParseNode CreateNode(Token token, string text)
        {
            ParseNode node = new ParseNode(token, text);
            node.Parent = this;
            return node;
        }

        protected ParseNode(Token token, string text)
        {
            this.Token = token;
            this.text = text;
            this.nodes = new List<ParseNode>();
        }

        protected object GetValue(ParseTree tree, TokenType type, int index)
        {
            return GetValue(tree, type, ref index);
        }

        protected object GetValue(ParseTree tree, TokenType type, ref int index)
        {
            object o = null;
            if (index < 0) return o;

            // left to right
            foreach (ParseNode node in nodes)
            {
                if (node.Token.Type == type)
                {
                    index--;
                    if (index < 0)
                    {
                        o = node.Eval(tree);
                        break;
                    }
                }
            }
            return o;
        }

        /// <summary>
        /// this implements the evaluation functionality, cannot be used directly
        /// </summary>
        /// <param name="tree">the parsetree itself</param>
        /// <param name="paramlist">optional input parameters</param>
        /// <returns>a partial result of the evaluation</returns>
        internal object Eval(ParseTree tree, params object[] paramlist)
        {
            object Value = null;

            switch (Token.Type)
            {
                case TokenType.Start:
                    Value = EvalStart(tree, paramlist);
                    break;
                case TokenType.Gramatica:
                    Value = EvalGramatica(tree, paramlist);
                    break;
                case TokenType.Sets:
                    Value = EvalSets(tree, paramlist);
                    break;
                case TokenType.CuerpoSets:
                    Value = EvalCuerpoSets(tree, paramlist);
                    break;
                case TokenType.ListaSets:
                    Value = EvalListaSets(tree, paramlist);
                    break;
                case TokenType.SetDef:
                    Value = EvalSetDef(tree, paramlist);
                    break;
                case TokenType.Def:
                    Value = EvalDef(tree, paramlist);
                    break;
                case TokenType.Tokens:
                    Value = EvalTokens(tree, paramlist);
                    break;
                case TokenType.DeclaracionTokens:
                    Value = EvalDeclaracionTokens(tree, paramlist);
                    break;
                case TokenType.CuerpoTokens:
                    Value = EvalCuerpoTokens(tree, paramlist);
                    break;
                case TokenType.ListaTokens:
                    Value = EvalListaTokens(tree, paramlist);
                    break;
                case TokenType.ListaDefToken:
                    Value = EvalListaDefToken(tree, paramlist);
                    break;
                case TokenType.CondicionToken:
                    Value = EvalCondicionToken(tree, paramlist);
                    break;
                case TokenType.OpcionalToken:
                    Value = EvalOpcionalToken(tree, paramlist);
                    break;
                case TokenType.DefToken:
                    Value = EvalDefToken(tree, paramlist);
                    break;
                case TokenType.SimpleToken:
                    Value = EvalSimpleToken(tree, paramlist);
                    break;
                case TokenType.AgrupaToken:
                    Value = EvalAgrupaToken(tree, paramlist);
                    break;
                case TokenType.Acciones:
                    Value = EvalAcciones(tree, paramlist);
                    break;
                case TokenType.DeclaracionAcciones:
                    Value = EvalDeclaracionAcciones(tree, paramlist);
                    break;
                case TokenType.CuerpoAcciones:
                    Value = EvalCuerpoAcciones(tree, paramlist);
                    break;
                case TokenType.FuncionReservadas:
                    Value = EvalFuncionReservadas(tree, paramlist);
                    break;
                case TokenType.CuerpoFunciones:
                    Value = EvalCuerpoFunciones(tree, paramlist);
                    break;
                case TokenType.ListaAcciones:
                    Value = EvalListaAcciones(tree, paramlist);
                    break;
                case TokenType.ListaFunciones:
                    Value = EvalListaFunciones(tree, paramlist);
                    break;
                case TokenType.OtrasFunciones:
                    Value = EvalOtrasFunciones(tree, paramlist);
                    break;
                case TokenType.Errores:
                    Value = EvalErrores(tree, paramlist);
                    break;
                case TokenType.ListaErrores:
                    Value = EvalListaErrores(tree, paramlist);
                    break;

                default:
                    Value = Token.Text;
                    break;
            }
            return Value;
        }

        protected virtual object EvalStart(ParseTree tree, params object[] paramlist)
        {
            return "Could not interpret input; no semantics implemented.";
        }

        protected virtual object EvalGramatica(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSets(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoSets(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaSets(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSetDef(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDef(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDeclaracionTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaTokens(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaDefToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCondicionToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalOpcionalToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDefToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalSimpleToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalAgrupaToken(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalDeclaracionAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalFuncionReservadas(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalCuerpoFunciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaAcciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaFunciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalOtrasFunciones(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalErrores(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }

        protected virtual object EvalListaErrores(ParseTree tree, params object[] paramlist)
        {
            foreach (var node in Nodes)
                node.Eval(tree, paramlist);
            return null;
        }


    }
    
    #endregion ParseTree
}
